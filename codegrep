#!/usr/bin/env python
#
# Copyright (C) 2016 Mattia Basaglia
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import sys
import os
import argparse
import re
import string
import magic

# Similar to grep but it gives proper context:
# if the matchin line is indented: print before/after with same indentation (optional)
# if the last printed line ends with \ include the following
# if a printed line has unmatched  [({ make sure to get up to the matchin ])}
# everything is to be limited by maximum context size
# Options to interpret comments/string

# TODO handle in LineMatch
class CommentContext(object):
    """
    Provides information on how to interpret comments.
    Here a comment is anything that should not be parsed as a single unit
    instead as a series of language tokens
    """
    def __init__(self, begin, end=None, multiline=False, ignores=[]):
        self.begin = begin
        self.end = end if end is not None else begin
        self.multiline = multiline
        if type(ignores) is str:
            ignores = [ignores]
        self.ignores = ignores


class BracketContext(object):
    """
    Provides information on how to match brackets
    """
    def __init__(self, open, close):
        self.open = open
        self.close = close


class Language(object):
    """
    Contains parsing information
    """
    def __init__(self, name,
                 file_extensions=[], mime_types=[],
                 comments=[], brackets=[]):
        self.name = name
        self.file_extensions = file_extensions
        self.mime_types = mime_types
        self.comments = comments
        self.brackets = brackets

    def bracket_counter(self):
        """
        Returns a dictionary that can be used to store bracket counts
        """
        return { bracket.open : 0 for bracket in self.brackets }

    def bracket_deltas(self):
        """
        Returns a dictionary that simplifies bracket counting
        """
        deltas = {}
        for bracket in self.brackets:
            deltas[bracket.open] = (bracket.open, +1)
            deltas[bracket.close] = (bracket.open, -1)
        return deltas


class LineMatch(object):
    """
    Object representing a match
    """

    def __init__(self, match, index, lines, language):
        # Line index of the beginning of the context
        self.context_begin = index
        # Line index of the beginning of the context
        self.context_end = index
        # Matched line index
        self.index = index
        # Index lines[index] of the beginning of the match
        self.match_begin = match.start()
        # Index lines[lines] line of the end of the match
        self.match_end = match.end()
        # List of lines
        self.lines = lines
        # Language
        self.language = language

    def expand(self, prev):
        """
        Expands the context for this match, possibly contracting it for prev
        """
        match_line = self.lines[self.index]
        last_space = 0
        while last_space < len(match_line) and match_line[last_space].isspace():
            last_space += 1
        self.indent = match_line[:last_space]

        self._brackets = self.language.bracket_deltas()
        self._expand_back(prev)
        self._expand_front()

    def _expand_back(self, prev):
        """
        Expands the context before the match
        """
        self.comment_context = None

        min = 0
        if prev is not None:
            if self.index <= prev.context_end + 1:
                prev.context_end = max(self.index - 1, prev.index)
                return
            min = prev.context_end

        brackets = self.language.bracket_counter()

        index = self.index - 1
        while index >= min and self._match_indent(index):
            self._parse_line(self.lines[index], brackets)
            index -= 1

        # TODO Consider comments, not only brackets
        while index >= min and any(brackets.values()):
            self._parse_line(self.lines[index], brackets)
            index -= 1

        self.context_begin = index + 1

    def _expand_front(self):
        """
        Expands the context after the match
        """
        self.comment_context = None

        brackets = self.language.bracket_counter()

        self._parse_line(self.lines[self.index], brackets)
        index = self.index + 1
        while index < len(self.lines) and self._match_indent(index):
            self._parse_line(self.lines[index], brackets)
            index += 1

        # TODO Consider comments, not only brackets
        while index < len(self.lines) and (
                any(brackets.values()) or self.comment_context
            ):
            self._parse_line(self.lines[index], brackets)
            index += 1

        self.context_end = index - 1

    def _match_indent(self, index):
        """
        Checks if the line at the given index matches the indentation
        extracted from the line matching the search pattern
        """
        return self.lines[index].startswith(self.indent) and (
            len(self.lines[index]) == len(self.indent) or
            not self.lines[index][len(self.indent)].isspace()
        )

    def _parse_line(self, line, counter):
        # Add/subtract from the bracket counters
        line = self._filter_forward_line(line)
        counts = count_chars(line, self._brackets.keys())

        for char, info in self._brackets.iteritems():
            counter[info[0]] += info[1]*counts[char]

    def _filter_forward_line(self, line):
        """
        Filters out comments from a context line
        """
        if self.comment_context:
            end = self.comment_context.end
            ignores = [
                (index, sz)
                for index, sz in
                (
                    (line.find(ign), len(ign))
                    for ign in self.comment_context.ignores
                )
                if index != -1
            ]
            start = 0
            for ignore in ignores:
                if end in line[start:ignore[0]]:
                    self.comment_context = None
                    line = line[ignore[1]:]
                    break
                start = ignore[1]
            else:
                return ""

        for comment in self.language.comments:
            begin = line.find(comment.begin)
            if begin != -1:
                self.comment_context = comment
                line = self._filter_forward_line(line[begin+len(comment.begin):])
                if not comment.multiline:
                    self.comment_context = None

        return line

    def print_match(self, formatter):
        """
        Prints this match
        """
        if self.context_begin < self.index:
            for line in range(self.context_begin, self.index):
                formatter.print_line(line, self.lines[line])

        formatter.print_match_line(self.index, self.lines[self.index],
                                   self.match_begin, self.match_end,)

        if self.context_end > self.index:
            for line in range(self.index+1, self.context_end+1):
                formatter.print_line(line, self.lines[line])


class Formatter(string.Formatter):
    """
    String formatter with special formatting flags and specialized funtions
    to print search matches
    """
    class Format:
        """
        Placeholder for formatting flags
        """
        pass

    _colors = {
        "black":   0,
        "red":     1,
        "green":   2,
        "yellow":  3,
        "blue":    4,
        "magenta": 5,
        "cyan":    6,
        "white":   7
    }

    _flags = {
        "bold":      1,
        "italic":    3,
        "underline": 4,
    }

    def __init__(self, color):
        self.color = color
        self.fmt_filename = "{fmt:green}{filename}{fmt}"
        self.fmt_line_prefix = "{fmt:bright_yellow}{line_num}{fmt}:"
        self.fmt_line_match = "{prefix}{pre_match}{fmt:bright_red,bold}{match}{fmt}{post_match}"
        self.fmt_line_context = "{prefix}{line}"
        self.fmt_line_skipped = "{fmt:bright_magenta}---{fmt}"

    def print_filename(self, filename):
        """
        Prints the filename as a match group
        """
        if self.fmt_filename:
            print self.format(self.fmt_filename, filename=filename)

    def match_prefix(self, line_number):
        """
        Returns the prefix for a match/context line
        """
        return self.format(
            self.fmt_line_prefix,
            line_num=line_number,
            filename=self._filename
        )

    def print_line(self, line_number, line):
        """
        Prints a line from the current file
        """
        sys.stdout.write(self.format(
            self.fmt_line_context,
            prefix=self.match_prefix(line_number),
            line=line,
            filename=self._filename
        ))

    def print_match_line(self, line_number, line, match_begin, match_end):
        """
        Prints a line containing a match
        """
        sys.stdout.write(self.format(
            self.fmt_line_match,
            prefix=self.match_prefix(line_number),
            pre_match=line[:match_begin],
            match=line[match_begin:match_end],
            post_match=line[match_end:],
            filename=self._filename
        ))

    def print_separator(self, line_from, line_to):
        """
        Prints a separator which delimits two sets of lines from the same file
        """
        if self.fmt_line_skipped:
            print self.format(
                self.fmt_line_skipped,
                line_from=line_from,
                line_to=line_to
            )

    def get_value(self, key, args, kwargs):
        """
        string.Formatter override, converts "fmt" into placeholders
        """
        if key == "fmt":
            return Formatter.Format()
        return super(Formatter, self).get_value(key, args, kwargs)

    def format_field(self, value, format_spec):
        """
        string.Formatter override, handles normal replacements as usual
        and formats the placeholders
        """
        if isinstance(value, Formatter.Format):
            return self.format_color(format_spec.split(","))
        return super(Formatter, self).format_field(value, format_spec)

    def format_color(self, format_list):
        """
        Returns a string that will produce the right color from a list
        of human-readable format flags
        """
        if not self.color:
            return ""

        codes = []

        for fmt in format_list:
            if not fmt:
                pass
            elif len(fmt) == 1 and fmt.isdigit():
                codes += [30+int(fmt)]
            elif fmt == "r" or fmt == "regular":
                codes += [22]
            elif fmt == "clear":
                codes = [0]
            elif fmt == "^*":
                codes += [39]
            elif len(fmt) == 2 and fmt[0] == "^" and fmt[1].isdigit():
                codes += [30+int(fmt[1])]
            elif fmt in Formatter._colors:
                codes += [30+Formatter._colors[fmt]]
            elif fmt.startswith("bright_") and fmt[7:] in Formatter._colors:
                codes += [90+Formatter._colors[fmt[7:]]]
            else:
                self._ansi_append(
                    self._ansi_flag_from_name(fmt),
                    codes
                )

        if codes:
            return "\x1b[%sm" % ";".join(map(str, codes))

        return "\x1b[0m"

    def _ansi_flag_negate(self, flag):
        """
        Returns an ansi formatting code that has the effect of cancelling the
        one passed as an argument
        """
        if flag == 1:
            return 24
        elif flag < 10:
            return 20+flag
        elif flag >= 30 and flag < 39:
            return 39
        elif flag >= 30 and flag < 39:
            return 39
        else:
            return flag

    def _ansi_flag_from_name(self, name):
        """
        Turns a human-readable name into an ansi formatting flag
        """
        if len(name) == 1:
            flag = next((
                flag
                for name, flag in Formatter._flags.iteritems()
                if name.startswith(name.lower)),
                None)
            if name.isupper():
                return self._ansi_flag_negate(flag)
            return flag

        if name in Formatter._flags:
            return Formatter._flags[name]

        if name.startswith("not_"):
            return self._ansi_flag_negate(self._ansi_flag_from_name(name[4:]))

        return None

    def _ansi_append(self, flag, list):
        """
        Appends the result of _ansi_flag_from_name to a list of flags
        """
        if flag is not None:
            list.append(flag)


def count_chars(string, chars=None):
    counts = [0 for _ in range(0, 128)]
    for char in string:
        counts[ord(char)] += 1

    if chars:
        return {ch: counts[ord(ch)] for ch in chars}

    return {
        chr(index): count
        for index, count in enumerate(counts)
        if count > 0
    }

def detect_language(file):
    """
    Returns a Language object based on the file and the global languages list
    """
    if file is not sys.stdin:
        mime = detect_language.magic.descriptor(file.fileno())
        for lang in languages.values():
            if mime in lang.mime_types:
                return lang

    for lang in languages.values():
        for ext in lang.file_extensions:
            if file.name.endswith(ext):
                return lang
    raise Exception("Unknown language")

detect_language.magic = magic.open(magic.ERROR|magic.MIME_TYPE)
detect_language.magic.load()


def search_file(file, pattern, formatter, language):
    """
    Search file for pattern
    file must be a file object
    """
    if is_binary_file(file):
        return
    if not language:
        language = detect_language(file)

    lines = list(file)
    matches = []
    for index, line in enumerate(lines):
        re_match = pattern.match(line)
        if re_match:
            line_match = LineMatch(re_match, index, lines, language)
            line_match.expand(matches[-1] if matches else None)
            matches.append(line_match)

    if not matches:
        return

    formatter._filename = file.name
    formatter.print_filename(file.name)
    previous_end = 0
    for match in matches:
        if previous_end and match.context_begin - 1 > previous_end + 1:
            formatter.print_separator(previous_end + 1, match.context_begin - 1)
        elif match.context_begin == previous_end + 2:
            formatter.print_line(previous_end + 1, lines[previous_end + 1])
        match.print_match(formatter)
        previous_end = match.context_end

    formatter._filename = ""


def is_binary_file(file, maxread=1024, threshold=0.3):
    """
    Whether a file is to be considered binary (instead of text)

    It reads the context of the given file objects and estimates whether it
    should be regarded as binary data.
    """

    # Assume the user knows what is typing/piping
    if file is sys.stdin:
        return False

    pos = file.tell()
    checked = file.read(maxread)
    file.seek(pos)

    # Empty file
    if not checked:
        return False

    no_ascii = 0
    for char in checked:
        if ord(char) == 0:
            return True
        if ord(char) > 127:
            no_ascii += 1

    return float(no_ascii) / len(checked) > threshold

def search_recurse(filename, pattern, formatter, language):
    """
    If filename is a directory, recurse else open and call search_file
    """
    if os.path.isdir(filename):
        for child in os.listdir(filename):
            search_recurse(os.path.join(filename, child), pattern, formatter, language)
    else:
        with open(filename) as file:
            search_file(file, pattern, formatter, language)

class Pattern(object):
    """
    A search pattern
    """
    def __init__(self, pattern, regex, re_flags=0):
        if not regex:
            pattern = re.escape(pattern)
        self.pattern = re.compile(pattern)
        self.flags = re_flags

    def match(self, line):
        return re.search(self.pattern, line, self.flags)

def args_any_of(*args):
    """
    Whether any of the function arguments is present as a command line argument
    """
    return any(x in sys.argv for x in args)

def args_none_of(*args):
    """
    Whether none of the function arguments is present as a command line argument
    """
    return all(x not in sys.argv for x in args)

def parse_args():
    arg_parser = argparse.ArgumentParser(description="Code Grep.", add_help=False)
    arg_parser.add_argument(
        "--help", "-?",
        action="help",
        help="Print this help message and exit."
    )

    arg_parser.add_argument(
        "-F",
        help="Fixed string pattern.",
        action="store_const",
        default="extended",
        const="fixed",
        dest="syntax",
    )
    arg_parser.add_argument(
        "-E",
        help="Extended regex pattern.",
        action="store_const",
        const="extended",
        dest="syntax",
    )
    arg_parser.add_argument(
        "-r", "-R", "--recurse",
        help="Recurse in directories.",
        action="store_true",
        dest="recurse",
    )
    arg_parser.add_argument(
        "-i", "--ignore-case",
        help="Case-insensitive search.",
        action="store_true",
        dest="icase",
    )
    arg_parser.add_argument(
        "--color", "--colour",
        help="Colorize output.",
        choices=["auto", "always", "never"],
        dest="color",
        default="auto",
    )
    arg_parser.add_argument(
        "--with-filename", "-H",
        help="Print the filename for each match.",
        action="store_true",
        default=True,
    )
    arg_parser.add_argument(
        "--no-filename", "-h",
        help="Suppress filename and line number output.",
        action="store_false",
        dest="with_filename",
    )
    arg_parser.add_argument(
        "--group",
        help="Group matches by file name.",
        action="store_true",
        default=True,
    )
    arg_parser.add_argument(
        "--nogroup", "--no-group",
        help="Don't group matches by file name.",
        action="store_false",
        dest="group",
    )

    # TODO allow this: codegrep -l c++ file1 file2 -l py file 3
    arg_parser.add_argument(
        "--lang", "-l",
        help="Language.",
        choices=languages.keys(),
        default=None,
    )

    if args_any_of("-e", "-f", "-?", "--help"):
        pattern_or_file = arg_parser.add_mutually_exclusive_group(required=True)
        pattern_or_file.add_argument(
            "-e",
            help="Search pattern.",
            dest="pattern",
            nargs=1
        )
        pattern_or_file.add_argument(
            "-f",
            help="File to search.",
            dest="files",
            nargs=1
        )
    if args_none_of(["-e", "-f"]):
        arg_parser.add_argument(
            "pattern",
            help="Search pattern.",
            nargs=1 if not args_any_of("-?", "--help") else '?'
        )
    arg_parser.add_argument(
        "files",
        help="Files to search.",
        nargs="*",
    )

    return arg_parser.parse_args()

std_brackets = [
    BracketContext('(', ')'),
    BracketContext('[', ']'),
    BracketContext('{', '}'),
]

languages = {
    "py": Language(
        "Python",
        [".py"],
        ["text/x-python"],
        [
            CommentContext('"""', multiline=True, ignores='\\"'),
            CommentContext("'''", multiline=True, ignores="\\'"),
            CommentContext('"', ignores='\\"'),
            CommentContext("'", ignores="\\'"),
            CommentContext("#", end="\n"),
        ],
        std_brackets
    ),

    "c++": Language(
        "C, C++ and similar",
        [".h", ".hxx", ".hpp", ".hh", ".h++", ".H", ".tlh",
         ".cpp", ".cc", ".C", ".c++", ".cxx", ".ocl", ".inl", ".idl", ".c",
         ".m", ".mm", ".M", ".y", ".ypp", ".yxx", ".y++", ".l"],
        ["text/x-c", "text/x-c++", "text/x-c++hdr", "text/x-c++src",
         "text/x-chdr", "text/x-csrc", "text/x-objchdr", "text/x-objcsrc"],
        [
            CommentContext('R"(', ')"', multiline=True),
            CommentContext('"', multiline=True, ignores='\\"'),
            CommentContext("'", multiline=True, ignores="\\'"),
            CommentContext("//", "\n"),
            CommentContext("/*", "*/", multiline=True),
        ],
        std_brackets
    ),

    "txt": Language(
        "Plain text",
        [".txt", ""],
        ["text/plain"],
        brackets=std_brackets
    ),
}

args = parse_args()

if not args.pattern or not args.pattern[0]:
    sys.exit()

flags = 0
if args.icase:
    flags |= re.IGNORECASE
pattern = Pattern(args.pattern[0], args.syntax == "extended", flags)

if args.color == "auto":
    color = sys.stdout.isatty()
else:
    color = args.color == "always"

formatter = Formatter(color)

if not args.with_filename:
    formatter.fmt_filename = ""
    formatter.fmt_line_prefix = ""
    formatter.fmt_line_skipped = ""
elif not args.group:
    formatter.fmt_line_prefix = formatter.fmt_filename + ":" + formatter.fmt_line_prefix
    formatter.fmt_line_skipped = ""
    formatter.fmt_filename = ""

language = None
if args.lang:
    language = languages[args.lang]

if not args.files:
    search_file(sys.stdin, pattern, formatter, language)
elif args.recurse:
    for filename in args.files:
        search_recurse(filename, pattern, formatter, language)
else:
    for filename in args.files:
        with open(filename) as file:
            search_file(file, pattern, formatter, language)
